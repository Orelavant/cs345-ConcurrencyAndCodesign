Lab 1 Reflection - Jacob Valero

Runs:
Paradigm: Sequential
Fibonacci Number: 30
Answer: 832040
Execution time in milliseconds: 2

Paradigm: Concurrent 1
Fibonacci Number: 30
Answer: 832040
Execution time in milliseconds: 3

Paradigm: Sequential
Fibonacci Number: 40
Answer: 102334155
Execution time in milliseconds: 273

Paradigm: Concurrent 1
Fibonacci Number: 40
Answer: 102334155
Execution time in milliseconds: 155

Paradigm: Sequential
Fibonacci Number: 48
Answer: 512559680
Execution time in milliseconds: 12899

Paradigm: Concurrent 1
Fibonacci Number: 48
Answer: 512559680
Execution time in milliseconds: 7669

Reflection: To come up with the concurrent algorithm, I realized that the recursive algorithm could
be initally split into two threads which each continue finishing the recursive work. For example, if
finding the 5th fibonacci number, two threads find the fibonacci numbers for 4 and 3 recursively,
and then add up their results to get the 5th number. Then after reading the chapter on concurrent 
Fibonacci from CaDCiJ that this splitting could occur at every branch of the recursive algorithm. 
Something that was suprising was that the concurrent 1 version consistently ran slower for the 30th 
fibonacci number. This may be attributed to a greater startup time when making threads, so it may be
the case that the speed gains from using threading are only apparent with greater loads of work. 